/**
 
 以下内容不一定是完全正确的 因为看到过不同的看法 暂时持怀疑态度
 
 关于连接
 
 TCP/IP通信方式分为连接与非连接型通讯方式
 
 TCP:TCP是一种可靠通信，每次通信需要建立一个专门的通信链路
 
 UDP:UDP通信是一种无连接方式，也称为Stateless，无需建立专门的连接链路，连接消耗成本低，但是数据传输并不可靠
 
 
 
 
 
 
 
 
 
 
 
 
 HTTP 属于应用层协议；在网络层使用IP协议，解决网络路由和寻址问题；在传输层使用Tcp协议，主要解决如何在IP层之上可靠的传输数据包，使得另一端收到发送端发送的所有包，并且顺序与发出的顺序一致，具有可靠、面向连接的特点。
 HTTP 协议是无状态的：协议对事务的处理没有记忆能力，服务器不知道客户端是什么状态，也就是打开一个服务器上的网页，和你之前打开的这个服务器上的网页没有什么关联。http是一个无状态的面向连接的协议。
    但是无状态不代表http不能保持tcp连接。更不能代表http 使用的是udp(无连接)
 在http1.0版本中默认使用的是短连接，也就是客户端和服务端每进行一次http操作，都建立一次连接，任务结束就中断连接。
 http1.1起 默认使用了长连接，保持连接。响应头加入Connection:keep-alive。打一个网页打开，Tcp连接不会关闭，客户端再次访问这个服务器上的网页，继续使用这一条已经建立的连接。Connection:keep-alive不会永久保持连接，有一个时间限制，这个时间可以在服务端设定。
 http的长连接 短连接，本质上是tcp的长连接，短连接。
 
 
 
 TCP
 当网络通信采用TCP协议时，在真正的读写操作之前，server和client之间必须建立一个连接，当读写操作完成之后，双方不再需要这个连接，可以释放掉。建立连接是需要三次握手的，而释放是需要四次握手的，所以每个连接的建立资源消耗时间消耗。
 TCP短连接 一般是客户端发起close，当然也可以是服务端发起；一旦发起则关闭连接。
 
 由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。
 
 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。
 
 长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择
 
 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。
 
 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。。
 
 HTTP短连接（非持久连接）是指，客户端和服务端进行一次HTTP请求/响应之后，就关闭连接。所以，下一次的HTTP请求/响应操作就需要重新建立连接。
 HTTP长连接（持久连接）是指，客户端和服务端建立一次连接之后，可以在这条连接上进行多次请求/响应操作。持久连接可以设置过期时间，也可以不设置。
 */

/**
 长连接
 所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。
 
 连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）；
 这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态；
 
 TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。
 
 如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：
 
 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
 客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
 客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。
 
 长连接的维持，是要客户端程序，定时向服务端程序，发送一个维持连接包的。如果，长时间未发送维持连接包，服务端程序将断开连接。
 由于客户端会定时（keepAliveDelay毫秒）发送维持连接的信息过来，所以，服务端要有一个检测机制。
 即当服务端receiveTimeDelay毫秒（程序中是3秒）内未接收任何数据，则自动断开与客户端的连接。
 ActionMapping的原理与客户端相似（相同）。
 
 
 
 */
