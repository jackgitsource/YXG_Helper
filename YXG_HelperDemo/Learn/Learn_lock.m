//
//  Learn_lock.m
//  YXG_KitDemo
//
//  Created by  on 2019/2/19.
//  Copyright © 2019 yxg. All rights reserved.
//

#import "Learn_lock.h"

@implementation Learn_lock

// 锁
/**
 YYKit组件 大量使用semaphore 和 pthread_mutex
 1. OSSPinLock 自旋锁 被证明不安全 性能最高；原因是do while盲等 会消耗大量CPU资源；不适合长期任务
 2. semaphore 信号量，没有等待情况下 效率很高；一旦有等待情况则 效率大大下降；相对于OSSPinLock 其优点在于 在等待时不消耗cpu资源
 3. pthread_mutex c语言的互斥锁 等待任务较长 建议使用 例如磁盘缓存
 */
/**
 锁的概念的引出
 进程：一个进程就是一个正在执行程序的实例 资源分配的最小单元，有运行 就绪 阻塞 三个状态
 线程：可以多个线程 共享同一个地址空间和其他资源 比如全局变量，进程中的不同线程 不像进程之间那样有很大的独立性；严格来说 同一时间只有一个线程占有cpu 只不过高速切换给人们带来并行的假象。
      有运行 就绪 阻塞 三个状态
      每个线程都有自己的堆栈
 */

/**
 自旋锁 互斥锁 概念 区别
 相同点：都以保证同一时间只有一个线程访问资源 都能保证线程安全
 自旋锁：如果共享资源已经有其他线程加锁了 则线程会以死循环的方式等待解锁 一旦被访问的资源被解锁 则等待资源的线程立即执行；
       自旋锁不释放cpu 因此持有自旋锁的线程 应尽快释放自旋锁 否则等待该自旋锁的线程会一直在那里死循环 浪费cpu时间
 互斥锁：如果共享资源已经有其他线程加锁了 则线程进入休眠状态等待解锁 一旦被访问的资源被解锁 则等待资源的线程会被唤醒
 自旋锁效率 > 互斥锁效率
 
 使用任何锁 都消耗系统资源 内存资源和cpu时间 一般是：建立锁所需要的资源 当线程被阻塞时需要的资源
 */

/**
 自旋锁的优先级反转问题 也是OSSPinLock 不再安全的原因
 放生在：低优先级线程拿到锁时 高优先级线程进入盲等状态 消耗大量的cpu时间 而导致了低优先级线程拿不到cpu时间 则无法完成任务 无法释放锁；这就称为优先级反转。
 
 那么就不得不说 操作系统如何管理线程调度的
 通常 普通线程 采用时间片轮转算法 每个线程会被分配一段时间片 10-100ms 当线程用完自己的时间以后 就会被操作系统挂起 等待下一次的被分配
 
 */

/**
 NSLock，NSCondition，NSRecursiveLock 只是基于上面几个的封装
 */

/**
 @synchronize 是一个OC层面的锁 牺牲性能换来语法上的简洁和可读
 需要传入 一个对象 这个对象的内存地址作为key 通过hash map对应一个系统维护的递归锁
 */

/**
 效率 OSSPinLock 和 semaphore性能最高
 @synchronize 和 NSConditionLock性能最低
 基于性能 可以考虑使用semaphore 不考虑性能 图方便则使用@synchronize
 
 对于OSSPinLock 由于优先级反转问题 苹果在ios推出了os_unfair_lock性能很高 但是需在ios10后使用
 */
@end
